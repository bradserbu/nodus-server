'use strict';

// ** Dependencies
const Q = require('q');
const uuid = require('uuid');

// ** Libraries
const EventEmitter = require('eventemitter2').EventEmitter2;
const Command = require('./Command');
const Component = require('./Component');

// ** Platform
const logger = require('nodus-framework').logging.createLogger();
const errors = require('nodus-framework').errors;
const functions = require('nodus-framework').functions;

/**
 * Constainer class for a request
 */
class PendingRequest extends EventEmitter {
    constructor(req, options, callback) {
        super();

        this.req = req;
        this.options = options; // TODO: Add timeout support
        this.callback = callback;
    }

    fail(err) {
        this.callback(err);
    }

    complete(response) {
        this.callback(null, response)
    }
}

/**
 * Container class for a Service.
 * - Contains commands to execute Tasks and preform Work.
 * - Respond to requests from Other services routed via the server.
 * - Send Requests to other services via the server.
 */
class Service extends Component {
    constructor(name, options) {
        super(name, options);

        this.isStarted = false;
        this._pendingRequests = {};
        this._requestHandlers = [];

        this._commands = {};

        this.on('response', res => this.receive_response(res));
    }

    addCommand(command) {
        const name = command.name;

        if (this._commands[name])
            throw errors('COMMAND_LOADED', {name: name}, 'A command with the same name has already been loaded.');

        this._commands[name] = command;
    }

    /**
     * Register a request handler with the service.
     * @param match Returns a true/false or a promise to a result.
     * @param handler
     */
    handle_request(match, handler) {
        this._requestHandlers.push(req => {
            if (!match(req)) return false;

            // ** Ensure args and options are set
            req.args = req.args || {};
            req.options = req.options || {};

            // ** Call the handler and receive the result
            const result = handler(req);

            // ** Ensure we always pass back a promise to a result.
            return Q.when(result);
        });
    }

    /**
     * Ask the service to respond to a request
     * @param req
     * @private
     */
    receive_request(req) {
        // ** Check if this request can directly be handled by the service
        for(let lcv=0; lcv<this._requestHandlers.length; lcv++) {
            const match = this._requestHandlers[lcv];

            // ** Check if we want to handle this message.
            // ** result is either false, or a Promise to a message
            const result = match(req);
            if (result) {
                return result;
            }
        }

        // ** Otherwise: Match the service and the command directly
        if (req.service !== this.name)
            return false;

        // ** Automatically try to call a command on this service
        const command = this._commands[req.command];
        if (command)
            return command.run(req.args, req.options);

        // ** We didn't match anything
        return false;
    }

    receive_response(res) {
        const id = res.id;
        const req = this._pendingRequests[id];

        if (!req) {
            const err = errors('NO_PENDING_REQUEST', {response: res}, 'A pending request could not be found for this response.');

            // ** Ensure this error is logged, even if no-one is here to catch it.
            logger.error(err);
            throw err;
        }

        // ** Remove this pending request as resolved
        delete this._pendingRequests[id];

        // ** Check for errors
        if (res.error)
            return req.fail(res.error);

        // ** Request completed successfully
        req.complete(res.result);
    }

    /**
     * Issues a request to the host to call another service
     * @param service
     * @param command
     * @param args
     * @param options
     */
    request(req, options) {

        // ** Get the Autogenerated ID of the request
        req.id = uuid();

        // ** Wait for a response
        return new Promise((resolve, reject) => {
            // ** Create a new pending request
            const pending_request = new PendingRequest(req, options, (err, result) => {
                if (err) return reject(err);

                resolve(result);
            });

            // ** Add this request to the list of pending requests
            this._pendingRequests[req.id] = pending_request;

            // ** Emit the request to be picked up by the server (or other listeners)
            this.emit('request', req);
        });
    }

    start() {
        if (this.isStarted) {
            logger.warn('SERVICE_STARTED', {service: this.name});
            return;
        }

        this.emit('start');
        this.isStarted = true;
        this.emit('started');
    }

    stop() {
        if (!this.isStarted) {
            logger.warn('SERVICE_STOPPED', {name: this.name});
            return;
        }

        this.emit('stop');
        this.isStarted = false;
        this.emit('stopped');
    }
}

// ** Exports
module.exports = Service;
module.exports.Service = Service;